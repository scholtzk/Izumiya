<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing Square Payment...</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #6F4E37;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            text-align: center;
        }
        .container {
            padding: 20px;
            max-width: 400px;
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .status {
            font-size: 18px;
            margin: 10px 0;
        }
        .error {
            color: #ff6b6b;
        }
        .success {
            color: #51cf66;
        }
        .debug-panel {
            position: fixed;
            bottom: 12px;
            left: 12px;
            right: 12px;
            background: rgba(0,0,0,0.85);
            color: #aef1ae;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.35;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 6px 24px rgba(0,0,0,0.35);
            text-align: left;
            max-height: 40vh;
            overflow: auto;
            display: none; /* auto-show on non-success */
        }
        .debug-panel h3 {
            margin: 0 0 8px 0;
            font-size: 12px;
            color: #fff;
        }
        .debug-row { margin-bottom: 6px; }
        .debug-key { color: #ffd166; }
        .debug-actions { margin-top: 8px; display: flex; gap: 8px; }
        .debug-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="spinner"></div>
        <div class="status" id="status">Processing Square payment...</div>
        <div id="details"></div>
    </div>
    <div id="debugPanel" class="debug-panel">
        <h3>Square Callback Debug</h3>
        <div id="debugContent"></div>
        <div class="debug-actions">
            <button id="copyDebugBtn" class="debug-btn">Copy Debug</button>
            <button id="hideDebugBtn" class="debug-btn">Hide</button>
        </div>
    </div>

    <!-- Firebase bootstrap (module) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
        import { getFirestore, collection, addDoc, getDocs, query, orderBy, updateDoc, doc, deleteDoc, getDoc, Timestamp, setDoc, where } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyD8nS3tRM8e6eeztv0l7XK9nyjsB9vjRTs",
            authDomain: "izumiya-pos.firebaseapp.com",
            projectId: "izumiya-pos",
            storageBucket: "izumiya-pos.firebasestorage.app",
            messagingSenderId: "548021570883",
            appId: "1:548021570883:web:0c9e5057613edd9067f3f6",
            measurementId: "G-H7F3BEJRQ8"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Minimal enhanced services (retry omitted for simplicity here)
        window.firebaseDb = db;
        window.firebaseServices = { collection, doc, addDoc, setDoc, updateDoc, deleteDoc, getDoc, getDocs, query, where, orderBy, Timestamp };
    </script>

    <script>
        // Initialize Firebase
        let firebaseServices = null;
        
        // Wait for Firebase to be fully loaded
        function waitForFirebase() {
            return new Promise((resolve) => {
                const checkFirebase = () => {
                    if (window.firebaseServices && window.firebaseDb) {
                        firebaseServices = window.firebaseServices;
                        console.log('Firebase services loaded successfully');
                        resolve();
                    } else {
                        console.log('Waiting for Firebase services...');
                        setTimeout(checkFirebase, 100);
                    }
                };
                checkFirebase();
            });
        }

        // Simple debug helpers
        function showDebugPanel() {
            const panel = document.getElementById('debugPanel');
            if (panel) panel.style.display = 'block';
        }
        function addDebug(key, value) {
            const el = document.getElementById('debugContent');
            if (!el) return;
            const pretty = typeof value === 'object' ? JSON.stringify(value, null, 2) : String(value);
            const row = document.createElement('div');
            row.className = 'debug-row';
            row.innerHTML = `<span class="debug-key">${key}:</span> <pre style="margin:4px 0 0; white-space:pre-wrap;">${pretty}</pre>`;
            el.appendChild(row);
        }
        function clearDebug() {
            const el = document.getElementById('debugContent');
            if (el) el.innerHTML = '';
        }

        // Parse Square callback data
        function parseSquareCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const dataParam = urlParams.get('data');
            
            if (!dataParam) {
                throw new Error('No data parameter found in Square callback');
            }
            
            try {
                const decodedData = decodeURIComponent(dataParam);
                const transactionInfo = JSON.parse(decodedData);
                console.log('Square callback data:', transactionInfo);
                addDebug('Decoded data', transactionInfo);
                return transactionInfo;
            } catch (error) {
                console.error('Error parsing Square callback data:', error);
                addDebug('Parse error', String(error && error.message ? error.message : error));
                throw new Error('Invalid Square callback data format');
            }
        }

        // Helper: today key and dailyOrders doc (same as app)
        function getTodayKey() {
            const today = new Date();
            return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        }
        async function getDailyOrdersDoc() {
            const todayKey = getTodayKey();
            const dailyOrdersRef = window.firebaseServices.doc(window.firebaseDb, 'dailyOrders', todayKey);
            const d = await window.firebaseServices.getDoc(dailyOrdersRef);
            if (!d.exists()) {
                await window.firebaseServices.setDoc(dailyOrdersRef, { date: todayKey, orders: {}, lastUpdated: window.firebaseServices.Timestamp.now() });
            }
            return dailyOrdersRef;
        }

        // Open ProSurf with query parameters (no redirect to main website)
        function redirectToProSurf(query) {
            const base = 'https://scholtzk.github.io/Izumiya/';
            const prosurfUrl = 'prosurf://' + base + (query || '');
            console.log('Opening ProSurf:', prosurfUrl);
            
            // Try to open ProSurf immediately
            window.location.href = prosurfUrl;
            
            // No fallback redirect - stay on callback page
            console.log('ProSurf opened. Staying on callback page.');
        }

        // Main processing function
        async function processSquareCallback(retryCount = 0) {
            try {
                // Wait for Firebase to be fully loaded
                document.getElementById('details').textContent = 'Connecting to Firebase services...';
                await waitForFirebase();
                
                const transactionInfo = parseSquareCallback();
                const statusElement = document.getElementById('status');
                const detailsElement = document.getElementById('details');
                clearDebug();
                addDebug('URL', window.location.href);
                addDebug('Query', Object.fromEntries(new URLSearchParams(window.location.search).entries()));
                addDebug('Transaction info', transactionInfo);
                
                // Check for success
                if (transactionInfo.status === 'ok' || transactionInfo.transaction_id || transactionInfo.client_transaction_id) {
                    statusElement.textContent = 'Payment successful!';
                    statusElement.className = 'status success';
                    detailsElement.textContent = 'Saving payment...';

                    // Move current order to completed (reuse app structure)
                    try {
                        addDebug('Firebase check', 'Starting Firebase operations...');
                        
                        // Check if Firebase services are available
                        if (!window.firebaseServices) {
                            throw new Error('Firebase services not available');
                        }
                        addDebug('Firebase services', 'Available');
                        
                        // Add timeout protection for Firebase operations (should be instant if working)
                        const timeoutDuration = retryCount > 0 ? 2000 : 1000; // 1s for first attempt, 2s for retries
                        const firebaseTimeout = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error(`Firebase operation timeout (${timeoutDuration}ms)`)), timeoutDuration)
                        );
                        
                        const firebaseOperation = async () => {
                            const dailyOrdersRef = await getDailyOrdersDoc();
                            addDebug('Daily orders ref', 'Retrieved');
                            
                            const d = await window.firebaseServices.getDoc(dailyOrdersRef);
                            addDebug('Document fetch', d.exists() ? 'Success' : 'Document does not exist');
                            
                            const data = d.data() || { orders: {} };
                            addDebug('Document data', data);
                            
                            const current = data.orders ? data.orders.current : null;
                            addDebug('Current order', current);
                            
                            if (!current) {
                                throw new Error('No current order found in Firebase');
                            }
                            if (!current.items) {
                                throw new Error('Current order has no items');
                            }
                            if (!current.orderNumber) {
                                throw new Error('Current order has no order number');
                            }
                            
                            addDebug('Order validation', 'Passed');
                            
                            // Get payment amount from URL parameters
                            const paymentAmount = parseFloat(transactionInfo.amount) || 0;
                            addDebug('Payment amount', paymentAmount);
                            
                            // Check if current order amount matches payment amount
                            if (current.total !== paymentAmount) {
                                // Amount doesn't match - search for Pay Later order with matching amount
                                addDebug('Order search', 'Current order amount does not match, searching unpaid orders...');
                                
                                const allOrders = data.orders || {};
                                const unpaidOrders = Object.values(allOrders).filter(order => 
                                    order.paymentStatus === 'unpaid' && 
                                    order.total === paymentAmount
                                );
                                
                                if (unpaidOrders.length > 0) {
                                    // Find the most recent unpaid order with matching amount
                                    const mostRecentOrder = unpaidOrders.reduce((latest, order) => {
                                        if (!latest) return order;
                                        return order.timestamp && order.timestamp > latest.timestamp ? order : latest;
                                    });
                                    
                                    addDebug('Order match', `Found unpaid order ${mostRecentOrder.orderNumber} with matching amount`);
                                    
                                    // Update the Pay Later order to paid
                                    const updatedOrder = {
                                        ...mostRecentOrder,
                                        paymentMethod: 'Card',
                                        tenderedAmount: mostRecentOrder.total,
                                        change: 0,
                                        paymentStatus: 'paid',
                                        timestamp: mostRecentOrder.timestamp, // Preserve original timestamp
                                        squareTransactionId: transactionInfo.transaction_id || transactionInfo.client_transaction_id,
                                        squareStatus: transactionInfo.status || 'ok'
                                    };
                                    
                                    const updated = { ...(data.orders || {}) };
                                    updated[updatedOrder.orderNumber] = updatedOrder;
                                    
                                    await window.firebaseServices.updateDoc(dailyOrdersRef, {
                                        orders: updated,
                                        lastUpdated: window.firebaseServices.Timestamp.now()
                                    });
                                    addDebug('Save result', 'success - Pay Later order updated');
                                    detailsElement.textContent = 'Pay Later order updated. Returning to POS...';
                                } else {
                                    throw new Error(`No order found with amount ${paymentAmount}`);
                                }
                            } else {
                                // Regular current order payment - use original logic
                                const completedOrder = {
                                    ...current,
                                    paymentMethod: 'Card',
                                    tenderedAmount: current.total,
                                    change: 0,
                                    paymentStatus: 'paid',
                                    timestamp: window.firebaseServices.Timestamp.now(),
                                    squareTransactionId: transactionInfo.transaction_id || transactionInfo.client_transaction_id,
                                    squareStatus: transactionInfo.status || 'ok'
                                };
                                addDebug('Completed order', completedOrder);
                                
                                const updated = { ...(data.orders || {}) };
                                delete updated.current;
                                updated[completedOrder.orderNumber] = completedOrder;
                                addDebug('Updated orders', updated);
                                
                                await window.firebaseServices.updateDoc(dailyOrdersRef, {
                                    orders: updated,
                                    lastUpdated: window.firebaseServices.Timestamp.now()
                                });
                                addDebug('Save result', 'success - Current order completed');
                                detailsElement.textContent = 'Saved. Returning to POS...';
                            }
                        };
                        
                        // Run Firebase operation with timeout protection
                        await Promise.race([firebaseOperation(), firebaseTimeout]);
                    } catch (saveErr) {
                        addDebug('Save result', 'failed');
                        addDebug('Save error type', typeof saveErr);
                        addDebug('Save error message', saveErr && saveErr.message ? saveErr.message : 'No message');
                        addDebug('Save error code', saveErr && saveErr.code ? saveErr.code : 'No code');
                        addDebug('Save error stack', saveErr && saveErr.stack ? saveErr.stack : 'No stack');
                        addDebug('Full error object', saveErr);
                        detailsElement.textContent = 'Payment save failed. Retrying...';
                        showDebugPanel();
                        
                        // Check if error is retryable (timeout, network issues) vs permanent (no current order)
                        const isRetryableError = saveErr.message.includes('timeout') || 
                                                saveErr.message.includes('network') || 
                                                saveErr.message.includes('connection') ||
                                                saveErr.code === 'unavailable';
                        
                        // Retry after 1 second (max 3 retries) only for retryable errors
                        if (retryCount < 3 && isRetryableError) {
                            setTimeout(() => {
                                console.log(`Retrying Firebase save operation... (attempt ${retryCount + 1}/3)`);
                                detailsElement.textContent = `Retrying payment save... (attempt ${retryCount + 1}/3)`;
                                // Recursively retry the same operation
                                processSquareCallback(retryCount + 1);
                            }, 1000);
                        } else {
                            // Non-retryable error or max retries reached
                            if (!isRetryableError) {
                                detailsElement.textContent = 'Payment save failed (permanent error). Returning to POS...';
                                console.log('Non-retryable error, redirecting to ProSurf for manual handling');
                            } else {
                                detailsElement.textContent = 'Payment save failed after 3 attempts. Returning to POS...';
                                console.log('Max retries reached, redirecting to ProSurf for manual handling');
                            }
                            
                            // Redirect to ProSurf for manual handling
                            const txId = transactionInfo.transaction_id || transactionInfo.client_transaction_id || '';
                            const query = `?square_success=1&transaction_id=${encodeURIComponent(txId)}`;
                            redirectToProSurf(query);
                        }
                        
                        return; // Don't redirect on failure
                    }
                    
                    // Only redirect to ProSurf on successful save
                    const txId = transactionInfo.transaction_id || transactionInfo.client_transaction_id || '';
                    const query = `?square_success=1&transaction_id=${encodeURIComponent(txId)}`;
                    redirectToProSurf(query);
                    
                } else if (transactionInfo.error_code) {
                    // Handle error
                    statusElement.textContent = 'Payment failed';
                    statusElement.className = 'status error';
                    detailsElement.textContent = `Error: ${transactionInfo.error_code}`;
                    showDebugPanel();
                    addDebug('Error code', transactionInfo.error_code);
                    
                    // Redirect to ProSurf immediately
                    const query = `?square_error=${encodeURIComponent(transactionInfo.error_code)}${orderNumber?`&orderNumber=${encodeURIComponent(orderNumber)}`:''}${total?`&total=${encodeURIComponent(total)}`:''}`;
                    redirectToProSurf(query);
                    
                } else {
                    // Handle cancellation or unknown status
                    statusElement.textContent = 'Payment cancelled';
                    statusElement.className = 'status error';
                    detailsElement.textContent = 'Payment was cancelled by user';
                    showDebugPanel();
                    addDebug('Outcome', 'cancelled');
                    
                    // Redirect to ProSurf immediately
                    const query = `?square_cancelled=1${orderNumber?`&orderNumber=${encodeURIComponent(orderNumber)}`:''}${total?`&total=${encodeURIComponent(total)}`:''}`;
                    redirectToProSurf(query);
                }
                
            } catch (error) {
                console.error('Error processing Square callback:', error);
                document.getElementById('status').textContent = 'Error processing payment';
                document.getElementById('status').className = 'status error';
                document.getElementById('details').textContent = error.message;
                showDebugPanel();
                addDebug('Fatal error', String(error && error.message ? error.message : error));
                
                // Still try to redirect to ProSurf immediately
                redirectToProSurf('');
            }
        }

        // Start processing when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Wire debug panel controls
            const copyBtn = document.getElementById('copyDebugBtn');
            const hideBtn = document.getElementById('hideDebugBtn');
            if (copyBtn) {
                copyBtn.addEventListener('click', async () => {
                    try {
                        const text = document.getElementById('debugContent').innerText || '';
                        await navigator.clipboard.writeText(text);
                        alert('Debug copied');
                    } catch (e) {
                        alert('Copy failed');
                    }
                });
            }
            if (hideBtn) {
                hideBtn.addEventListener('click', () => {
                    const panel = document.getElementById('debugPanel');
                    if (panel) panel.style.display = 'none';
                });
            }

            // Allow forcing debug via ?debug=1
            const qp = new URLSearchParams(window.location.search);
            if (qp.get('debug') === '1') {
                showDebugPanel();
                addDebug('Forced debug', true);
            }
            processSquareCallback();
        });
    </script>
</body>
</html>
